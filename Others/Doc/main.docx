ماژول main:

خلاصه:
این ماژول در‌واقع نقش ارتباط بین روتر ها و پردازنده هر روتر با روتر مربطه اش را انجام می‌دهد. در‌واقع ورودی ها و خروجی های هر پورت روترها را از روتر یا پردازه ای که باید می‌گیرد و در روتر مقصد می‌گذارد. همچنین تمام instance های روترها و پردازنده‌ها درون این ماژول قرار دارند و در نتیجه فایل‌های ورودی را نیز این ماژول می‌خواند و پردازش می‌کند.
جزئییات:
این ماژول ابتدا ورودی‌ها را از فایل می‌خواند. برای این قسمت سعی کردیم از دستور $readmemh  استفاده کنیم تا قالبیت سنتز داشته باشد. سپس اطلاعات خوانده شده را در آرایه هایی دسته بندی می‌کنیم. پس از این به اندازه حداکثر روتر هایی که در فایل پارامتر مشخص شده با استفاده از generate block ، از router و traffic نمونه می‌گیریم. هر کدام از  این نمونه‌ها با یک state machine کار میکنند و state آن‌ها از طریق این ماژول بیرونی main به وسیله ورودی که از پورت op اشان می‌گیرند، کنترل می‌شود.
پس از این فرآیند‌ها این ماژول مانند یک state machine عمل می‌کند که سر هر لبه clock یا reset تغییر وضعیت می‌دهد. حالت‌های آن و فعالیت‌های مربوط به هر بخش این‌گونه است:
InitState: این حالت اولیه ایست که هر بار اگر reset ۱ شود به این حالت باز‌می‌گردیم و تمام کار‌های اولیه را انجام می‌دهد مانند ورودی خواندن از فایل.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت nop می‌بریم. 
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت nop می‌بریم.
وضعیت بعدی خود ماژول: به حالت InitTraffic می‌رویم.
InitTraffic: در این حالت به تمام پردازنده‌ها تعداد ترافیک دریافتیشان را می‌دهیم و آن هارا آماده اجرای دستورات بعدی می‌کنیم. 
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت nop می‌بریم. 
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت Init می‌بریم.
وضعیت بعدی خود ماژول: به حالت FillTraffic می‌رویم.
FillTraffic: در این حالت به تمام پردازنده‌ها ترافیک هایی را که از فایل خوانده بودیم می‌دهیم. در هر کلاک یک ترافیک و اگر ترافیکمان تمام شد آن پردازنده را بی‌کار می‌کنیم.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت nop می‌بریم. 
وضعیت پردازنده‌ها: پردازنده هایی که هنوز تمام پکت هایشان را نگرفته اند، به حالت fill و سایر پردازنده ها به وضعیت nop در می‌آیند.
وضعیت بعدی خود ماژول: به حالت FillTraffic می‌رویم اگر پردازنده ای باشد که در این وضیعت fill بوده. در غیر اینصورت یعنی تمام پردازنده ها ترافیک مربوط به خودشان را گرفته‌اند و به وضعیت PreDequeTraffic می‌رویم.
PreDequeTraffic: در این حالت تمام پردازنده‌ها صف مربوطه اشان را آماده می‌کنند و خروجیشان را برابر اولین ترافیکی که در قسمت قبل به آن‌ها داده شده بود می‌کنند تا در ادامه بتوانیم از خروجی آن‌ها استفاده کنیم.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت nop می‌بریم. 
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت PreDeque می‌بریم.
وضعیت بعدی خود ماژول: به حالت InitRouter می‌رویم.
InitRouter: در این حالت تمام روتر‌ها را آماده سازی ‌می‌کنیم و اطلاعاتی که از ورودی خوانده‌ایم مانند تعداد پورت‌های ورودی و خروجی هر روتر را به آن می‌دهیم.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت Init می‌بریم. 
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت nop می‌بریم.
وضعیت بعدی خود ماژول: به حالت LoadRtRouter می‌رویم.
LoadRtRouter: در این حالت routing table ای که از ورودی خوانده‌ایم را به روتر‌ها می‌دهیم و هر مرحله یک عضو routing table را به روتر مربوطه‌اش می‌دهیم.
وضعیت روتر‌ها:  تمام روتر هایی که routing table اشان را هنوز کامل دریافت نکرده اند را به وضعیت LoadRt می‌بریم و بقیه را به حالت nop.
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت nop می‌بریم.
وضعیت بعدی خود ماژول: به حالت LoadRtRouter می‌رویم اگر روتری باشد که ورودی اش را کامل نخوانده، در غیر اینصورت به حالت LoadStagingRouter می‌رویم.
LoadStagingRouter: در این حالت خروجی هر پردازنده را نگاه می‌کنیم و در صورتی که کانال مجازی متناظرش در روتر خالی باشد، این خروجی را در ورودی پورت ۰ روتر می‌گذاریم تا در نیم کلاک بعد، آن را بخواند (زیرا روتر ها با negedge clock کار می‌کنند). همچنین با توجه به اتصالاتی که از ورودی خوانده‌ایم، خروجی هر پورت هر روتر را در ورودی پورت روتر مقصد می‌گذاریم. از طرفی هر روتری برای اینکه اعلام کند vc اش خالی شده باید در جهت عکس به روتر دیگر پیام بفرستد بنابر‌این پیامی در جهت عکس اتصالات نیز از روتر مقصد به‌ مبدأ می‌فرستیم.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت LoadStaging می‌بریم. 
وضعیت پردازنده‌ها:  پردازنده هایی که خروجی آن‌ها وارد روتر می‌شود را به حالت Deque می‌بریم زیرا باید خروجیشان را تا clock بعدی دور بریزند و flit بعدی را بدهند. سایر پردازنده ها را به حالت nop می‌بریم.
وضعیت بعدی خود ماژول: به حالت Phase0Router می‌رویم.
Phase0Router: در این حالت تمام روتر‌ها فعالیت مرحله صفرشان را روی ورودی های گرفته شده انجام می‌دهند.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت Phase0 می‌بریم. 
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت nop می‌بریم.
وضعیت بعدی خود ماژول: به حالت Phas1Router می‌رویم.
Phase1Router: در این حالت تمام روتر‌ها فعالیت مرحله یکشان را روی ورودی های گرفته شده انجام می‌دهند.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت Phase1 می‌بریم. 
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت nop می‌بریم.
وضعیت بعدی خود ماژول: به حالت CheckEnd می‌رویم.
CheckEnd: در این حالت هر روتر را چک ‌می‌کنیم که آیا کارش تمام شده یا خیر و در صورتی که تمام روتر‌ها کارشان تمام شده بود خروجی is_end را یک می‌کنیم و کار تمام است در غیر این‌صورت باید باز هم پکت ها را جا به جا کنیم و دوباره به حالت‌های قبلی رمی‌گردیم. همچنین در این وضعیت cycle هارا یک واحد زیاد می‌کنیم تا تعداد مراتبی که عملیات جابه‌جایی را انجام داده‌ایم بشماریم.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت nop می‌بریم. 
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت nop می‌بریم.
وضعیت بعدی خود ماژول: در صورتی که همه روتر ها کارشان تمام شده باشد به حالت EndState می‌رویم و در غیر اینصورت به حالت LoadStaging برمی‌گردیم.
EndState: حالت پایانی است و به حالت بی‌کار در می‌آید.
وضعیت روتر‌ها:  تمام روتر ها را به وضعیت nop می‌بریم. 
وضعیت پردازنده‌ها:  تمام پردازنده‌ها را به حالت nop می‌بریم.
وضعیت بعدی خود ماژول: به حالت EnState می‌رویم.
